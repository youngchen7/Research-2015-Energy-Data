<!DOCTYPE HTML>
<html>
<head>
	<title>ac_vis</title>
	<style>
		body {
			margin: 0;
			padding: 0;
			background-color: #000000;
		}
	</style>
	<script src="/js/pixi.min.js"></script>
	<script src="/js/shp.min.js"></script>
	<script src="/js/d3.min.js"></script>
	<script src="/js/chroma.min.js"></script>

</head>
<body onclick = "resetAnim()">
	<script>
	// create a renderer instance.
	//var renderer = new PIXI.CanvasRenderer(800, 800, {resolution: 2});
	var renderer = new PIXI.WebGLRenderer(800, 800, {antialias: true, resolution: 2, backgroundColor:0x000000});
	renderer.view.style.width = '800px';
	renderer.view.style.height = '800px';

	// add the renderer view element to the DOM
	document.body.appendChild(renderer.view);

	// create an new instance of a pixi stage
	var stage = new PIXI.Container();

	var india = new PIXI.Container();

	//Create the text overlay
	var date = new PIXI.Text("Click to play", {font : '36px Segoe UI', fill : 0xdab20d});
	date.position = {x: 600, y: 700};

  // animation variables
	var anim_run = false;
	var anim_index = 0;
	var anim_color = chroma.scale(["black", "#dab20d"]).domain([0, 63]);
	var scalemode = 'default';
	var scaleparam = 0;

	// load constituency file
	shp("/data/AC_India_Geo_Simpl/AC_ALLINDIA").then(function(geojson){
		//Sadly hardcoded in right now. TODO fix by parsing geojson for the bounding box.
		var india_bounds = [68.11029052734375, 8.084136962890625, 97.40910339355469, 37.02901077270508];
		var india_cx = (india_bounds[0]+india_bounds[2])/2;
		var india_cy = (india_bounds[1]+india_bounds[3])/2;
		geojson.features.forEach(function(polygon)
		{
			var points = polygon.geometry.coordinates[0];
			var constituency = new PIXI.Graphics();
			var scale = {x:25, y:-25};

			//Attach an ID
			constituency["id"] = (polygon.properties["STATE"] + ":" + polygon.properties["AC_ID"]).toUpperCase();
			//transform the points with the correct scale and translation
			points.forEach(function(el, ind, arr){
				arr[ind] =  [Math.trunc((el[0] - india_cx)*scale.x), Math.trunc((el[1] - india_cy)*scale.y)];
			});

			//Discard duplicates (webGL does not like duplicates)
			var seen = {};
			var count = 0;
			points = points.filter(function(el){
				if(seen.hasOwnProperty(el)){
					//Duplicate found, discard and count
					++count;
					return false;
				}else{
					//First time seeing this one, keep it
					seen[el] = true;
					return true;
				}
			});

			//Flatten points to draw polygon
			var poly_points = [].concat.apply([], points);

			//Start drawing the constituency
			constituency.beginFill(0xFFFFFF);
			constituency.lineStyle(1, 0x000000);

			constituency.drawPolygon(poly_points);
			constituency.endFill();

			india.addChild(constituency);

		});
		india.position.x = 400;
		india.position.y = 400;
		stage.addChild(india);
		//Add the date display
		stage.addChild(date);
		console.log("India loaded");
	}).then(function(){
		//Okay, India's loaded. Now start rendering.
		console.log("Rendering started");
		requestAnimationFrame( animate );
	});

	//Load CSV file
	var data;
	d3.csv("/data/generated/AC_India_Data_Formatted.csv").get(function(error, rows){
		console.log("CSV Data Read");
		data = rows;
	});
	
	
	//Helper to scale a row of data 
	function updateData(data, mode, param)
	{
		//Check if mode was specified, if not, set it to 'default'
		mode = typeof mode === 'undefined' ? 'default' : mode;	
		//Run bounds checking on the data
		data.forEach(function(el, index, arr)
		{
			//Bounds checking 
			arr[index] = el > 63 ? 63 : el < 0 ? 0 : el;
		});	
		//Run mode specific scaling
		switch(mode)
		{	
			//Square root scale data
			case 'sqrt':
				data.forEach(function(el, i){
					data[i] = Math.sqrt(el/63)*63;
				});
				break;
			//Logarithmically scale data
			case 'log':
				data.forEach(function(el, i){
					data[i] = Math.log(el+1)/Math.log(64)*63;
				});
				break;
			//Stretch the middle param %
			case 'stretch':
				if(!param)
					param = 100;
				var num_spread = Math.floor(data.length*param/100);		
				console.log("Num spread %d", num_spread);		
				var map = data.map(function(el, i){
					return i;
				});
				map.sort(function(a, b){
					return data[a] - data[b];
				})
				//Set minimum to include num_spread/2 below the median
				var min = data[map[Math.floor(data.length/2 - num_spread/2)]];
				//Set maximum to include num_spread/2 above the median
				var max = data[map[Math.floor(data.length/2 + num_spread/2)-1]];
				console.log("Min: %d, Max: %d", min, max);
				//Scale each point (bounding will fix outliers later)
				data.forEach(function(el, index, arr)
				{
					arr[index] = (el - min) * (63 / (max - min));
				});
				break;
			//Divide into 'param' groups and smooth
			case 'group':
				if(!param)
					param = 64;
				var num_each = data.length / param;
				var map = data.map(function(el, i){
					return i;
				});
				map.sort(function(a, b){
					return data[a] - data[b];
				})
				map.forEach(function(el, i){
					//Which group # are we at?
					var group = i/num_each;
					//Calculate value based on total groups (param) and current group
					var val = Math.floor(group) * (63/param);
					data[el] = val;
				})
				break;
		}
		//Run bounds checking on the data again
		data.forEach(function(el, index, arr)
		{
			//Bounds checking 
			arr[index] = el > 63 ? 63 : el < 0 ? 0 : el;
		});
	}

	//Helper to update tint for every AC
	function updateTint()
	{
		//Create the row of relevant data
		var data_row = []
		india.children.forEach(function(child)
			{
				var id = child.id;
				var vis = Number(data[anim_index][id]);
				data_row.push(vis);
			});
		//Update the data (re scale for most variance)
		updateData(data_row, scalemode, scaleparam);
		//Update the tint
		india.children.forEach(function(child, index)
			{
				var vis = data_row[index];				
				//console.log("Updating tint for %s, vis %d", id, vis);
				child.tint = "0x" + anim_color(vis).hex().substring(1);
			});
	}
	
	//Function to change the scale mode and parameter
	
	function setMode(mode, param)
	{
		scalemode = mode;
		scaleparam = param;
		resetAnim();
	}

	//Helper function to advance the animation one "step"
	function stepAnim()
	{
		if(anim_index < data.length)
		{
			console.log("Showing India as of %s-%s", data[anim_index]["Month"], data[anim_index]["Year"]);
			var date_text = " " + data[anim_index]["Month"] + "-" + data[anim_index]["Year"];
			date.text = date_text.substr(-7);
			updateTint();
			anim_index += 1;
		}
	}

	function resetAnim()
	{
		if(data)
		{
			anim_index = 0;
			anim_run = true;
		}
	}

	function checkMatch()
	{
		//Build {ID, bool} pair for mapIDs
		var mapIDs = {};
		india.children.forEach(function(child)
		{
			var id = child.id;
			mapIDs[id] = false;
		});

		//Build {ID, bool} pair for csvIDs
		//Might as well mark all mapIDs that show up while we're iterating
		var csvIDs = {};
		for (var id in data[0])
		{
			if(data[0].hasOwnProperty(id))
			{
				//If this ID shows up in our map
				if(mapIDs.hasOwnProperty(id))
				{
					//remove the ID that showed up in both
					if(!delete mapIDs[id])
						{
							//There was an issue removing the ID
							console.log("Could not delete object property %s", id);
						}
				}
				else {
					//Stick the ID in csvIDs, it didn't show up in map!
					csvIDs[id] = false;
				}
			}
		}
		//Print the mismatched IDs
		//Might as well mark all dataIDs that show up while we're iterating
		console.log("mismatched IDs in the map");
		console.log(mapIDs);
		console.log("mismatched IDs in the data");
		console.log(csvIDs);
	}

	//Render function
	function animate() {
		  requestAnimationFrame( animate );
			//Step the animation
			if(anim_run)
				stepAnim();
	    // render the stage
	    renderer.render(stage);
	}



	</script>

	</body>
</html>
